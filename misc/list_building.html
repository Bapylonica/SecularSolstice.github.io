<!doctype HTML>
<html>
    <head>
        <title>List Builder</title>
        <script src="gen/autocomp.js"></script>
	<script src='../../theme-switcher.js'></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<link rel=stylesheet href=../theme.css>
        <style>
        </style>
    </head>
    <body style="width:unset;">
	<h1>Program Building Helper</h1>
	<p>Use this specialized-autocomplete-enabled text box to
	    construct a program.  Just write
	    songs, speeches or activities with their file/directory
	    names and sections with a single leading <tt>#</tt> sign.
	    You can include notes about speeches (e.g. which litany of
	    tarksi) with a colon, a tagline for the whole thing with curly
	    braces, or autoslide-only audio links with parentheses after a
	    song name.
	</p>
	<p>Optionally, start from an existing program:
	    <select id="programs"></select>
	    <input type="button" value="load" id="loadbtn"></input></p>
	<p>When you're done, c+p this
	    into a new <tt>.list</tt> file in the <tt>lists</tt>
	    directory.  You can use
	    <a href="https://github.com/SecularSolstice/SecularSolstice.github.io/new/master/lists">Github's GUI</a>
	    for this if you like.</p>
	<p>Or create an <input id="autoslide" value="Autogenerated Slide Show" type="button"></input> of your
	    program, complete with audio to sing along to, for use in
	    smaller solstices.  Note that list slide show is not saved
	    everywhere, so you should probably c+p the program
	    somewhere safe first.</p>
	<table width="100%"><tr>
            <td>
                <textarea cols="50" rows="50" id="content"
			  style="background: rgba(255,255,255,0.7);"></textarea>
            </td>
            <td id="annots" style="position:relative;min-width:200px;width:100%"></td>
            <td id="info" valign="top"></td>
        </tr></table>

        <script>

         cont = $('#content')[0];
         lh = cont.getBoundingClientRect().height / cont.rows;
         annots = []
         for (var i=0; i<$('#content').prop('rows'); i++) {
             annots.push($('<div>').css('position','absolute')
                                   .css('top',Math.floor(i*lh)+'px')
                                   .css('z-index','0')
                                   .appendTo($('#annots')));
         }
         
         function dbg(str) {
             $('<p>').text(str).appendTo($('#info'));
         }

         function common_start(l){
             for (var pos=0; pos<999; pos++) {
                 for (i in l) {
                     if (pos > l[i].length ||
                         l[i].substring(0,pos) != l[0].substring(0,pos)) {
                         return pos-1;
                     }
                 }
             }
             return 'ERROR!';
         }
         
         $('#content').keydown(function(ev){
             if (ev.which!=13) return;
             this.selectionStart = this.selectionEnd;
         });

         $('#content').keyup(function(ev){
             if ( (ev.which<48 || ev.which>127) &&
                  ev.which!=8 && // Backspace
                  ev.which!=13 && // New line
                  ev.which!=46) { // Delete
                 return;
             }

             lines = this.value.split('\n')
             for (i in lines) {
                 annots[i].empty()
                          .css('z-index','0')
                          .css('white-space','nowrap');
                 li = lines[i].split(':')[0];
                 if (li in content) {
                     $('<b>').text(content[li][0]+' ').appendTo(annots[i]);
                     $('<i>').text(content[li][1]+': ').appendTo(annots[i]);
                     $('<span>').text(content[li][2]).appendTo(annots[i]);
                 }
             }
             for (; i<annots.length; i++) {
                 annots[i].empty();
             }

             if (ev.which < 48) return;
             
             ss = this.selectionStart;
             se = this.selectionEnd;
             if (ss != se) return;
             val = this.value;
             lastsp = val.lastIndexOf(' ',ss-1);
             lastrt = val.lastIndexOf('\n',ss-1);
             lasthash = val.lastIndexOf('#',ss-1);
             wordstart = Math.max(lastsp,lastrt)+1;
             prefix = val.substring(wordstart,ss);
             if (prefix=='') return;
             //dbg(prefix);
             options=[];
             if (lasthash > lastrt) {
                 for (i in sections) {
                     if (sections[i].startsWith(prefix)) options.push(sections[i]);
                 }
             } else {
                 for (c in content) {
                     if (c.startsWith(prefix)) options.push(c);
                 }
             }
             if (options.length==0) return;
             len_common = common_start(options);
             to_insert = options[0].substring(prefix.length, len_common);
             this.value = val.substring(0,ss) + to_insert + val.substring(ss)
             this.setSelectionRange(ss, ss+to_insert.length, 'backward')
             if (options.length>1) {
                 line = val.substring(0,ss).split('\n').length - 1;
                 annots[line].empty()
                             .css('z-index','1')
                             .css('white-space','normal');
                 $('<div>').text(options.join('\n'))
                           .css('background','#aaa')
                           .css('border-radius','3px')
			   .css('white-space', 'pre-line')
                           .appendTo(annots[line]);
             }
         });

	 async function read(url) {
	     let ifr = $(`<iframe src=${url}></iframe>`).css({display:'none'}).appendTo($('body'));
	     let ev=(await new Promise( res => ifr.on('load',res) ));
	     let txt = ifr[0].contentWindow.document.body.innerText;
	     // console.log(txt);
	     ifr.remove();
	     return txt;
	 }
	 
	 for (let i of programs) {
	     $(`<option value="${i}">${i.replace(/_/g,' ')} ${taglines[i]||''}</option>`)
		 .appendTo($('#programs'));
	 }

	 $('#loadbtn').on('click', async ()=> {
	     let pick = $('#programs')[0].value;
	     let url = `../lists/${pick}.list`;
	     console.log('fetching ',pick,url)
	     $('#content').val(await read(url)).trigger('keyup',{});
	 });

	 $('#autoslide').on('click', async () => {
	     /*global*/ slides = [];
	     let lines = $('#content').val().split('\n');
	     for (let line of lines) {
		 if (line.startsWith('#')) {
		     slides.push({type:'section', 'title':line.replace(/#+ */,'')});
		 } else if (line.trim() == '' || line.startsWith('{')) {
		     continue;
		 } else if (line in content) {
		     if (content[line][2] == '[speech]') {
			 slides.push({type:'text', title:content[line][0], link:line});
		     } else {
			 let lyrics = (await read(`../songs/${line}/gen/${line}-lyrics.txt`)).split('\n');
			 let readme = (await read(`../songs/${line}/README.md`));
			 let youtube = readme.match(/\(https:\/\/www.youtube.com\/watch\?v=([a-zA-Z0-9_-]*)\)/);
			 let mp3 = null;
			 if (youtube) {
			     youtube = youtube[1];
			     console.log(line,'has youtube',youtube)
			 } else {
			     mp3 = readme.match(/\((https?:\/\/[^)]*\.mp3)\)/);
			     if (mp3) mp3 = mp3[1];
			     console.log(line,'has mp3',mp3)
			 }
			 slides.push({type:'song', title:content[line][0], lyrics, youtube, mp3});
			 }
		 } else {
		     slides.push({type:'section', title:`?? ${line} ??`});
		 }
	     }
	     let sc=$('<script src=../auto-slide.js></' + 'script>').appendTo($('body'));
	     await new Promise( res => sc.on('load', res) );
	     $('body').on('keypress', (ev) => {
		 console.log('kp');
		 if (ev.which == 27 /* esc */) {
		     cancelSlides();
		 }
	     });
	     $('body').trigger('load');
	 });
        </script>
        
    </body>
</html>
